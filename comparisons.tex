\section{Comparisons}
Given $\share{x}$ where $x \in \Z_{2^k}$ our goal is to compute a ring sharing of $\share{x} > 0$.
This translates into how to compute a sharing of the most significant bit $\share{\mathsf{msb}(x)}$.
Since we are in the 3PC semi-honest model there are few approaches to this:
\begin{enumerate}

   \item SecureNN: there's some extra preprocessing which needs to be done
   although the round complexity seems to be a bit lower than ABY3 - need to
   check this though. The downside is that it uses arithmetic modulo weird
   fields. IMO we should stick with ABY3 because it either operates on rings
   or boolean type (so a bit more standard than SecureNN).
   \item ABY3:
   There's an implementation of this in MP-SPDZ as well, using
   the \textit{split} option when compiling a program. The main idea is for
   each party to locally bit-decompose their shares over $\Z_{2^k}$ and then
   reconstruct the secret modulo $\Z_{2^k}$ using shares from $\Z^k_2$ and a
   binary adder. Once we get a sharing of the MSB then in order to use it in
   other operations we need to convert the sharing back to one in $\Z_{2^k}$.
   In ABY3 this was done using a three-party OT protocol. In MP-SPDZ this was
   achieved using a daBit.
   However when using tensors case we can achieve this much easier by making
   use that all parties follow the protocol as described.
   Basically $P_3$ generates a
   daBit $(\share{b}_2, \share{b}_{2^k})$ locally and sends it additively
   shared to $P_1$ and $P_2$. The two parties $P_1, P_2$ convert the
   $\share{x}_2$ to $\share{x}_{2^k}$ by computing $c \asn
   \mathsf{Open}(\share{x}_2 \oplus \share{b}_2)$ and then locally XOR-ing in
   the arithmetic domain $\share{x}_{2^k} = c + \share{b}_{2^k} - 2 \cdot c \cdot
   \share{b}_{2^k}$. Finally they convert the $(2,2)$ sharing of $\share{x}_{2^k}$ 
   to a $(2,3)$ sharing locally.
   \item The newest one is using edaBits \cite{C:EGKRS20}. The downside of
   this method is that we need to implement edaBit generation and a boolean
   circuit doing binary addition. The upside of this is that for 3PC
   semi-honest the edaBit generation doesn't seem to be that hard ie
   we can avoid the cut and choose since everyone will execute the protocol
   semi-honestly.
\end{enumerate}

\input{protocols/2-out-of-2.tex}