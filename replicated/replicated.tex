\section{Replicated Placements}

In this section we expect the reader to have some familiarity with some basic
knowledge of how multiparty computation works, linear algebra and finite
field arithmetic. We strongly recommend reading the first sections
\cite{evans2017pragmatic} and more important Chapter 7 about honest majority
MPC.

In the last couple of years there was a boom in MPC for honest majority,
especially in 3PC one. This can be tracked down from the work of Araki et al.
\cite{CCS:AFLNO16} which at the moment provides the best performance for
semi-honest security in the preprocessing model. One year after this was
converted into a protocol with active security which achieves $1$ billion AND
triples per second \cite{SP:ABFLLN17} which had a cost of $7$ bits per AND
gate. Later it was shown by Keller et al. \cite{SCN:KRSW18} how to extend the
work of Araki et al. \cite{CCS:AFLNO16} to multiple parties assuming there is
honest majority using some well-known techniques by Maurer
\cite{SCN:Maurer02}. The caveat of Keller et al. \cite{SCN:KRSW18} is that
there can be an exponential blowup in terms of $n \choose t$ where $t<n/2$ is
the corruption threshold and $n$ the number of parties.


\subsection{Rationale}

For the linear regression use-case we believe that $128$ bit field size is
enough using a fixed point precision by $16$ bits while keeping the numbers
magnitude to $40$ bits (thus making the integral part of size $24$ bits). We
should keep in mind that although triple generation for large fields is
usually faster than rings there are benefits when working with ring sharings
- such as faster methods for secret truncation which in turn makes RELU's
faster.

Concretely, for the LR use-case we need to support a limited number of
operations on secret data but most important is a large secret matrix-matrix
multiplication. On cleartext data these multiplications are dealt using
floating point arithmetic, however when computing on encrypted data one must
unroll complex circuits into finite field operations. For this we stick to
fixed point computations described later in Section~\ref{subsec:fixed-point}.
Note that the underlying arithmetic can be either field ($\Fp$) or ring based
($\Z_{2^k}$). Finally, we might want to add some Gaussian noise over the
output to avoid one party getting the input matrix of the other party.

To get a better picture of the available protocols with their underlying
arithmetic we list the current state of the art protocols for obtaining
honest-majority MPC. For readability purposes we abbreviate honest majority
with HM:

\begin{enumerate}
  \item HM over large fields $\Fp$ \cite{CCS:LinNof17,C:CGHIKL18}. Although
  the two constructions listed above are specialized for the malicious
  setting (at most 1 party arbitrarily deviating from the protocol) these are
  built assuming $\Frand, \Fmult$ hybrid model where $\Fmult$ needs to be a
  multiplication protocol secure up to additive attacks. To get such an
  $\Fmult$ we can simply take
  a semi-honest protocol for HM for doing multiplications such as \cite{CCS:AFLNO16}.
  \item HM for binary circuits $\F_2$. Note that Araki et al. \cite{CCS:AFLNO16}
  works for binary circuits as well for the semi-honest case.
  To get malicious security Chida et al. \cite{C:CGHIKL18} present a protocol
  for small field multiplications using cut-and-choose techniques The cut and
  choose framework works by generating large batches of triples
  optimistically and then open a fraction to detect whether some cheating
  occurred.
  \item HM over small fields (eg. $\F_{2^8}$ which is suitable for AES). To
  get malicious security, depending on the extension field size, we can
  either repeat the computation $\sec/|\F|$ times or generate triples using cut and choose
  from \cite{C:CGHIKL18}.
  \item HM over rings $\mathbb{Z}_{2^k}$. Abspoel et al. \cite{EPRINT:ADEN19}
  are the first ones who introduce vector dot-products of secret shares at a cost of
  communicating a constant number of ring elements independently of the vector sizes
  for the ring case - however they avoid giving any hint on how to realise
  reactive computations, this is solved later in \cite{cryptoeprint:2020:1330}.
  \item HM by mixing circuits: \cite{CCS:MohRin18,cryptoeprint:2020:1330}.
  Escudero et al. \cite{C:EGKRS20} work in the more generic setting but they
  have
  improvements for the honest majority as well. They improve the mixed framework
  specifically for $\Z_{2^k}$ and $\F_2$ very recently in \cite{cryptoeprint:2020:1330}.

\end{enumerate}

Note that almost every protocol can be built in the malicious setting using
building blocks from the semi-honest protocols with the exception of binary
triples $c = a \cdot b$ where $a,b \in \F_2$. For the binary triple case we
need more complex techniques such as cut and choose. In our implementation we
stick with Araki et al. protocol \cite{CCS:AFLNO16} while borrowing some
improvements from \cite{cryptoeprint:2020:1330} such as probabilistic
truncation. One additional feature of Araki et al. \cite{CCS:AFLNO16} is that
it can be upgraded to malicious security by (roughly) just repeating all
procedures twice and use a "zero check" described in Dalskov, Escudero and
Keller \cite{cryptoeprint:2020:1330}.

\noindent{\textbf{Notation}}. We denote $\inc{i}$ as $i \mapsto (i+1) \bmod 3 + 1$.
Next, we denote $\share{x}$ as a value $x$ being secret shared
across the parties. In the cases below each party has a `replicated share` of
$x$, meaning $P_i$ has $(x_i, x_{ \inc{i+1} })$ where $\sum_{i=1}^3 = x
\in \Z_{2^k}$.

\subsection{Basic protocols}
\noindent{\textbf{Addition}}. To add two secret shares $\share{x}$ and $\share{y}$
each party locally adds their shares and computes $\share{x+y} =
(x_i + y_i, x_{\inc{i}} + y_{\inc{i}})$ for all $i \in [3]$.

\input{protocols/mul}




\subsection{Advanced protocols}
\input{dot-product}

\subsubsection{Truncation}
Given $\share{a}$ compute $\share{a \bmod 2^m}$ where $m$ is a public constant.
There are many ways to truncate a secret which can be roughly classified into 2:
\begin{itemize}
  \item probabilistic truncation - correct result with probability $p$.
  \item deterministic truncation - always output the exact truncation.
\end{itemize}

\noindent
The state of the art techniques in truncating a secret are using
dabits/edabits as described by Escudero et al. in \cite{C:EGKRS20} and
various share conversions. In \cite{C:EGKRS20} there are several techniques
to achieve both probabilistic and deterministic truncation for field and ring
case.

If we want to avoid edabit generation required for generating random bounded integers
by the truncation protocols in \cite{C:EGKRS20} then we can use the protocols from
\cite{PoPETS:DalEscKel20}. We describe their probabilistic protocols for replicated secret
sharing below in Fig~\ref{fig:truncpr-rep-ss}.

\begin{Boxfig}{Truncation protocol for semi-honest
RSS.}{fig:truncpr-rep-ss}{Protocol $\Proto{\mathsf{TruncPrSp}}$}
On input
$\mathsf{TruncPrSp}(\share{x}, m)$ from all parties where $x$ is a sharing
over $\Z_{2^k}$: \\
$P_3$ does the following:
  \begin{enumerate}
    \item Sample locally random bits $r_i$ for $i \in [0, k-1]$.
    \item Generate additive shares ($2$-out-of-$2$) for $r = \sum_{i=0}^{k-1}r_i$,
    $r_{k-1}$ and $\sum_{i=m}^{k-2} r_i \cdot 2^{i-m}$. Send the corresponding shares
    to $P_1$ and $P_2$.
    \item Generate random numbers $y_1, y_3 \in \Z_{2^k}$. Send $y_1$ to
    $P_1$ and $y_3$ to $P_2$.
    \item Set own share of the truncation result as $(y_3, y_1)$.
 \end{enumerate}
$P_1$ together with $P_2$ do the following:

\begin{enumerate}
   \item Convert $\share{x}$ into a $2$-out-of-$2$ sharing. This is
   accomplished by $P_1$ setting its local share to $x_1 + x_2$ while $P_2$
   setting its local share as $x_3$.
   \item $P_1$ and $P_2$ then execute the protocol $\Proto{\mathsf{TruncPR}}$
   using the $2$-out-of-$2$ sharings of $x$ and the shares provided by $P_3$.
\end{enumerate}
 Now parties convert the $2$-out-of-$2$ sharing output of
 $\mathsf{TruncPR}$ to a $2$-out-of-$3$
 sharing using the randomness provided by $P_3$.
 \begin{enumerate}
   \item Each $P_i$ for $i \in [1, 2]$ sets the output of $\mathsf{TruncPr}$
   as $y'_i$ and $\hat{y}_i$ as the sharing received from $P_3$. Send $y'_i -
   \hat{y}_i$ to $P_{3-i}$. The received values are denoted by $\tilde{y}_i$.
   \item $P_1$ sets the output share as $(y_1, y'_1 - \hat{y}_1 + \tilde{y}_1)$
   \item $P_2$ sets the output share as $(y'_2 - \hat{y}_2 + \widehat{y}_2, y_3)$.
 \end{enumerate}
\end{Boxfig}

\begin{Boxfig}{Generic truncation protocol.}{fig:truncpr-generic}
  {Protocol $\Proto{\mathsf{TruncPr}}(\share{x}, m)$}
  Assume $x \in \Z_{2^k}$ has $\mathsf{MSB}(x) = 0$. If $x$ is negative than
  we make it positive by adding $2^{k-1}$ to it and assume that $\mathsf{abs}(x) < 2^{k-1}$.
  \\
  On input $\mathsf{TruncPr}(\share{x}, m)$ from all parties:
  \begin{enumerate}
    \item Sample $k$ random bits $\share{r_i}$ and compute $r = \sum_{i=1}^k
    r_i$. \item Open $c \asn \share{x} + \share{r}$, truncate $c$ publicly
    and
    assign it to $c' \asn (c/2^m) \bmod 2^{k-m-1}$.
    \item Compute $\share{b} \asn \share{r_{k-1}} \oplus (c / 2^{k-1})$.
    \item Output $c' - \sum_{i=m}^{k-2} \share{r_i} \cdot 2^{i-m} + \share{b}
    \cdot 2^{k-m-1}$.
  \end{enumerate}

\end{Boxfig}


Note that although the protocol in Fig~\ref{fig:truncpr-rep-ss} looks
very efficient, the edabit variant from \cite{C:EGKRS20} requires
about $\approx 35$ times less communication.

\input{fixed-point-division}
\input{comparisons}
\import{key-distribution}{infra.tex}

