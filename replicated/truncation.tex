\subsection{Truncation}
\label{subsec:truncation}

Given a secret shared tensor $\share{\va}$ the goal is to compute $\share{\va \bmod 2^m}$
where $m$ is a public constant. There are many ways to truncate a secret, i.e. compute $\share{a \bmod 2^m}$), that
can be roughly classified into two lines of thought: the more efficient but with a rounding
error (probabilistic
truncation) while the other slightly less efficient but with no rounding errors (deterministic
truncation).

Current state of the art techniques in truncating a secret use
dabits/edabits as described by Escudero et al. in \cite{C:EGKRS20} together with
various share conversions. In \cite{C:EGKRS20} there are several techniques
to achieve both probabilistic and deterministic truncation for field and ring
case. For our special case of semi-honest three-parties model, 
we implement the probabilistic truncation from Dalskov et al. \cite{PoPETS:DalEscKel20} 
which avoids additional preprocessing such as edabits and have slightly better performance.
For more details on edabits versus Dalskov et al. the reader can check Table 10 in \cite{C:EGKRS20}.
We describe Dalskov et al. probabilistic protocol $\mathsf{TruncPR}$ for replicated secret
sharing below in Fig~\ref{fig:truncpr-rep-ss}. 

At a high-level the idea is to convert the replicated sharing to a $(2,2)$ additive sharing
and then execute the truncation protocol between two parties Figure~\ref{fig:truncpr-generic}. 
The preprocessing for the 2PC computation is 
generated by $P_3$ which is later additively shared to $P_1$ and $P_2$ using Figure~\ref{fig:get-additive}. After the two-party truncation is done, the output share is then converted
back to a replicated sharing using Figure~\ref{fig:two-to-three}. Correctness and security follow from work of Dalskov et al \cite{PoPETS:DalEscKel20}.


\begin{Boxfig}{Ring truncation protocol for semi-honest
RSS.}{fig:truncpr-rep-ss}{$\mathsf{TruncPr}{[P_1, P_2, P_3]}(\share{\vx}, m)$}
\begin{enumerate}
  \item Let $\left( (k_1^1, k_2^1), (k_2^2, k_3^2), (k_2^3, k_1^3) \right) = \prfkeys$ be PRF keys generated during setup.
  \item On $P_3$:
  \begin{enumerate}
    \item For $i \in [k]$ call $\seed(i) \asn \derives(\dkey_3, \GenNonce)$.
    \item For $i \in [k]$ sample random bits $\mathbf{b}_i \sample \mathsf{Sample}(\seed(i), \mathsf{Shape}(\vx), [0,1])$.
    \item Compute
    $\mathbf{r}_{\mathsf{bot}} \asn \sum_{i=0}^{k-1}2^i \cdot \vb(i)$,
    $\mathbf{r}_{\mathsf{msb}} \asn \vb(k-1)$ and
    $\mathbf{r}_{\mathsf{top}} \asn \sum_{i=m}^{k-2} \vb(i) \cdot 2^{i-m}$.
    \item For each of $\vr_{\mathsf{bot}}, \vr_{\mathsf{msb}} \vr_{\mathsf{top}}$
    generate 2-out-of-2 additive shares by calling $\mathsf{AdditiveShare}[D=P_3, P_1, P_2](\cdot)$
    on each entry and get $
    \vr\ui_{\mathsf{bot}}, \vr\ui_{\mathsf{msb}}, \vr\ui_{\mathsf{top}}$ for $i \in [1,2]$.
 \end{enumerate}
\item On $P_1$:
\begin{enumerate}
  \item Set $\vx'_1 \asn \vx_1^1 + \vx_2^1$.
\end{enumerate}

\item On $P_2$:
\begin{enumerate}
    \item Set $\vx'_2 \asn \vx_3^2$.
\end{enumerate}
\item Let $\share{\vx'} = \text{Additive}(\vx'_1, \vx'_2)$.

\item On ($P_1, P_2$):
\begin{enumerate}
   \item Run $\textsf{2PCTruncPr}[P_1, P_2](\share{\vx'}, m)$ protocol to get $\share{\vy}$.
  \item Convert the $2$-out-of-$2$ sharing $\vy$ to a $2$-out-of-$3$
 sharing. Parties output $\textsf{AdditiveToRep}[P_1, P_2, P_3](\share{\vy})$.
\end{enumerate}
\end{enumerate}

%  \begin{enumerate}
%    \item Each $P_i$ for $i \in [1, 2]$ sets the output of $\mathsf{TruncPr}$
%    as $y'_i$ and $\hat{y}_i$ as the sharing received from $P_3$. Send $y'_i -
%    \hat{y}_i$ to $P_{3-i}$. The received values are denoted by $\tilde{y}_i$.
%    \item $P_1$ sets the output share as $(y_1, y'_1 - \hat{y}_1 + \tilde{y}_1)$
%    \item $P_2$ sets the output share as $(y'_2 - \hat{y}_2 + \widehat{y}_2, y_3)$.
%  \end{enumerate}
\end{Boxfig}

\begin{Boxfig}{Generic truncation protocol.}{fig:truncpr-generic}
  {$\mathsf{2PCTruncPr}[P_1, P_2](\share{\vx}, m)$}
  Assume $\vx \in \Z_{2^k}^{\shape}$ has $\mathsf{MSB}(\vx) = 0$. If $\vx$ is negative then
  we make it positive by adding $2^{k-1}$ to it and assume that $\mathsf{abs}(\vx) < 2^{k-1}$.
  \begin{enumerate}
  \item With Additive($P_1,P_2$):
  \begin{enumerate}
    \item Compute $\vc = \Open(\share{\vx} + \share{\vr_{\mathsf{bot}}})$.
    \item $\vc' \asn (\vc/2^m) \bmod 2^{k-m-1}$. This can be done using one $\mathsf{ring\_shl}$
    followed by one $\mathsf{ring\_shr}$ operation.
    \item Compute $\share{\vb} \asn \share{\vr_{\mathsf{msb}}} \oplus (\vc / 2^{k-1})$. Note here that $\oplus$
    in arithmetic circuits boils down to $a + b - 2a\cdot b$. Here one of the operands is public so
    the result can be computed using only local operations.
    \item Output $\vc' - \share{\vr_{\mathsf{top}}} + \share{\vb} \cdot 2^{k-m-1}$.
 \end{enumerate}
\end{enumerate}

\end{Boxfig}


\begin{Boxfig}{Local conversion to $(2,2)$ additive shares.
  }{fig:get-additive}
  {$\mathsf{AdditiveShare}[D, P_1, P_2](R; \vx)$}
  \begin{enumerate}
    \item Roles: D, $P_1$, $P_2$ where $\vx.\mathsf{placement}$ is Host(D).
    \item With D:
  \begin{enumerate}
    \item $\seed \asn \derives(\dkey_D, \GenNonce)$.
    \item $\vx^1 \asn \RingSample(R; \mathsf{Shape}(\vx), \seed)$.
    \item $\vx^2 \asn \vx - \vx^1$.
    \item Send $\vx^i$ to $P_i$.
  \end{enumerate}
  \item With $P_1$:
  \begin{enumerate}
      \item Receive $\vx^1$ from Dealer.
  \end{enumerate}
  \item With $P_2$:
  \begin{enumerate}
      \item Receive $\vx^2$ from Dealer.
  \end{enumerate}
  \item Let $\vx = \text{Additive}(\vx^1, \vx^2)$.
\end{enumerate}
\end{Boxfig}



% \begin{Boxfig}{Opening protocol}{fig:open2-3}
%   {Protocol $\Proto{\mathsf{OpenTo}}^{(2,3)}(\share{\vx})$}
%   On $P_i$:
%   \begin{enumerate}
%     \item Send $\vx_1$ to $P_2$.
%   \end{enumerate}
%    On $P_2$:
%   \begin{enumerate}
%     \item Send $\vx_2$ to $P_1$.
%   \end{enumerate}
%   On $P_1$
%   \begin{enumerate}
%     \item Receive $\vx_2$ from $P_2$. Output
%     $\vx \asn \vx_1 + \vx_2$.
%   \end{enumerate}
%   On $P_2$
%   \begin{enumerate}
%     \item Receive $\vx_1$ from $P_1$. Output $\vx \asn \vx_1 + \vx_2$.
%   \end{enumerate}
% \end{Boxfig}





