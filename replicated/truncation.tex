\subsection{Truncation}
\label{subsec:truncation}

Given a replicated tensor $\share{\va}$ the goal is to compute $\share{\va \bmod 2^m}$ where $m$ is a public constant. The ways of doing this can roughly be classified into two lines of thought: the more efficient but with a rounding error (probabilistic truncation) while the other slightly less efficient but with no rounding errors (deterministic
truncation).

Current state of the art techniques use dabits/edabits as described by Escudero et al. in \cite{C:EGKRS20} together with various share conversions. In~\cite{C:EGKRS20} there are several techniques to achieve both probabilistic and deterministic truncation for field and ring case. For our special case of semi-honest three-parties model, 
we implement the probabilistic truncation from Dalskov et al. \cite{PoPETS:DalEscKel20} 
which avoids additional preprocessing such as edabits and have slightly better performance.
For more details on edabits versus Dalskov et al. the reader can check Table 10 in \cite{C:EGKRS20}.
We describe Dalskov et al. probabilistic protocol $\mathsf{TruncPR}$ for replicated secret
sharing below in Fig~\ref{fig:truncpr-rep-ss}. 

At a high-level the idea is to convert the replicated sharing to a $(2,2)$ additive sharing
and then execute the truncation protocol between two parties Figure~\ref{fig:truncpr-generic}. 
The preprocessing for the 2PC computation is 
generated by $P_3$ which is later additively shared to $P_1$ and $P_2$ using Figure~\ref{fig:get-additive}. After the two-party truncation is done, the output share is then converted
back to a replicated sharing using Figure~\ref{fig:two-to-three}. Correctness and security follow from work of Dalskov et al \cite{PoPETS:DalEscKel20}.


\begin{Boxfig}{Ring truncation protocol for semi-honest
RSS.}{fig:truncpr-rep-ss}{$\mathsf{TruncPr}_{[P_1, P_2, P_3]} \left(\Z_{2^k}; \prfkeys, \share{\vx}, m \right)$}
\begin{enumerate}
  \item Let $\left( (k_1^1, k_2^1), (k_2^2, k_3^2), (k_3^3, k_1^3) \right) = \prfkeys$.
  
  \item Let $\left( (\vx_1^1, \vx_2^1), (\vx_2^2, \vx_3^2), (\vx_3^3, \vx_1^3) \right) = \share{\vx}$.
  
  \item On $P_3$:
  \begin{enumerate}
    \item $\shape \asn \mathsf{Shape}(\vx^3_3)$.
    \item $\mathsf{key} \asn \mathsf{GenPrfKey}()$.
    \item $\seed_\ell \asn \derives(\ell; k)$ for $\ell \in [n]$.
    \item $\mathbf{b}_\ell \asn \mathsf{SampleBits}(\shape, \seed_\ell)$ for $\ell \in [n]$.
    \item $\mathbf{r}_{\mathsf{msb}} \asn \vb_{k-1}$
    \item $\mathbf{r}_{\mathsf{bot}} \asn \sum_{\ell=0}^{k-1}2^\ell \cdot \vb_\ell$
    \item $\mathbf{r}_{\mathsf{top}} \asn \sum_{\ell=m}^{k-2} 2^{\ell-m} \cdot \vb_\ell$.
  \end{enumerate}

  \item $\share{\vr_{\mathsf{msb}}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr_{\mathsf{msb}})$

  \item $\share{\vr_{\mathsf{bot}}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr_{\mathsf{bot}})$
  
  \item $\share{\vr_{\mathsf{top}}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr_{\mathsf{top}})$
 
  \item $\share{\vx'} \asn \mathsf{ReplicatedToAdditive}_{[P_1, P_2]}(\share{\vx})$.

  \item $\share{\vy'} \asn \mathsf{2PCTruncPr}_{[P_1, P_2]}(\share{\vx'}, m)$.

  \item Return $\share{\vy} \asn \mathsf{AdditiveToReplicated}_{[P_1, P_2, P_3]}(\share{\vy'})$.

\end{enumerate}

%  \begin{enumerate}
%    \item Each $P_i$ for $i \in [1, 2]$ sets the output of $\mathsf{TruncPr}$
%    as $y'_i$ and $\hat{y}_i$ as the sharing received from $P_3$. Send $y'_i -
%    \hat{y}_i$ to $P_{3-i}$. The received values are denoted by $\tilde{y}_i$.
%    \item $P_1$ sets the output share as $(y_1, y'_1 - \hat{y}_1 + \tilde{y}_1)$
%    \item $P_2$ sets the output share as $(y'_2 - \hat{y}_2 + \widehat{y}_2, y_3)$.
%  \end{enumerate}
\end{Boxfig}

\begin{Boxfig}{Generic truncation protocol.}{fig:truncpr-generic}
  {$\mathsf{2PCTruncPr}_{[P_1, P_2]} \left( \share{\vx}, m \right)$}
  Assume $\vx \in \Z_{2^k}^{\shape}$ has $\mathsf{MSB}(\vx) = 0$. If $\vx$ is negative then
  we make it positive by adding $2^{k-1}$ to it and assume that $\mathsf{abs}(\vx) < 2^{k-1}$. \commentM{Dragos could you add a few more details here?}
  \begin{enumerate}
  
  \item $\share{\vc} \asn \share{\vx} + \share{\vr_{\mathsf{bot}}}$.
  
  \item $\vc^1, \vc^2 \asn \Open_{[P_1, P_2]}(\share{\vc})$.
  
  \item On $P_i$ for $i \in [2]$:
    \begin{enumerate}
    \item $\vc_t^{i} \asn (\vc^i / 2^m) \bmod 2^{k-m-1}$. This can be done using one $\mathsf{ring\_shl}$ followed by one $\mathsf{ring\_shr}$ operation.
    \end{enumerate}
    
  \item $\share{\vb} \asn \share{\vr_{\mathsf{msb}}} \oplus (\vc / 2^{k-1})$. Note here that $\oplus$ in arithmetic circuits boils down to $a + b - 2a\cdot b$. Here one of the operands is public so the result can be computed using only local operations.
    
  \item Return $\share{\vy} \asn \vc_t - \share{\vr_{\mathsf{top}}} + \share{\vb} \cdot 2^{k-m-1}$.
\end{enumerate}

\end{Boxfig}


\begin{Boxfig}{Additive sharing.}{fig:get-additive}
  {$\mathsf{AdditiveShare}_{[D, P_1, P_2]}(R; \vx)$}
  
  Let $D$ be the party holding $\vx$.
  
  \begin{enumerate}
    \item On $D$:
  \begin{enumerate}
    \item $\shape \asn \mathsf{Shape}(\vx)$.
    \item $k \asn \mathsf{GenPrfKey}()$.
    \item $\seed \asn \derives(0; k)$.
    \item $\vx^1 \asn \RingSample(R; \shape, \seed)$.
    \item $\vx^2 \asn \vx - \vx^1$.
    %\item Send $\shape$ and $\seed$ to $P_1$.
    \item Send $\vx^1$ to $P_1$.
    \item Send $\vx^2$ to $P_2$.
  \end{enumerate}
  \item On $P_1$:
  \begin{enumerate}
      \item Receive $\vx^1_1$ from Dealer.
      %\item $\vx^1 \asn \RingSample(R; \mathsf{Shape}(\vx), \seed)$.
  \end{enumerate}
  \item On $P_2$:
  \begin{enumerate}
      \item Receive $\vx^2_2$ from Dealer.
  \end{enumerate}
  \item Return $\share{\vx} = (\vx^1_1, \vx^2_2)$.
\end{enumerate}
\end{Boxfig}

\begin{Boxfig}{Conversion from replicated shares to additive shares.}{fig:replicated-to-additive}
  {$\mathsf{ReplicatedToAdditive}_{[P_1, P_2]}\left( \share{\vx} \right)$}
  
  \begin{enumerate}
  
  \item Let $\left( (\vx_1^1, \vx_2^1), (\vx_2^2, \vx_3^2), (\vx_3^3, \vx_1^3) \right) = \share{\vx}$.
  
  \item On $P_1$:
    \begin{enumerate}
    \item $\vx'_1 \asn \vx^1_1 + \vx^1_2$.
    \end{enumerate}
    
  \item On $P_2$:
    \begin{enumerate}
    \item $\vx'_2 \asn \vx^2_3$.
    \end{enumerate}
  
  \item Return $\share{\vx'} = (\vx'_1, \vx'_2)$.
\end{enumerate}
\end{Boxfig}



% \begin{Boxfig}{Opening protocol}{fig:open2-3}
%   {Protocol $\Proto{\mathsf{OpenTo}}^{(2,3)}(\share{\vx})$}
%   On $P_i$:
%   \begin{enumerate}
%     \item Send $\vx_1$ to $P_2$.
%   \end{enumerate}
%    On $P_2$:
%   \begin{enumerate}
%     \item Send $\vx_2$ to $P_1$.
%   \end{enumerate}
%   On $P_1$
%   \begin{enumerate}
%     \item Receive $\vx_2$ from $P_2$. Output
%     $\vx \asn \vx_1 + \vx_2$.
%   \end{enumerate}
%   On $P_2$
%   \begin{enumerate}
%     \item Receive $\vx_1$ from $P_1$. Output $\vx \asn \vx_1 + \vx_2$.
%   \end{enumerate}
% \end{Boxfig}





