\subsection{Truncation}
\label{subsec:truncation}

Given a replicated tensor $\share{\vx}$, the goal of the truncation protocol is
to compute $\share{\vx \bmod 2^m}$ where $m$ is a public constant.
%The ways of doing this can roughly be classified into two lines of thought: the
%more efficient but with a rounding error (probabilistic truncation) while the
%other slightly less efficient but with no rounding errors (deterministic
%truncation).  Current state of the art techniques use dabits/edabits as
%described by Escudero et al. in \cite{C:EGKRS20} together with various share
%conversions. In~\cite{C:EGKRS20} there are several techniques to achieve both
%probabilistic and deterministic truncation for field and ring case.
For the semi-honest 3PC case we implement the probabilistic
truncation from~\cite{PoPETS:DalEscKel20} where the preprocessing is done by one party ($P_3$ for eg)
which is then secret shared to the other two parties ($P_1$ and $P_2$).
%and have slightly better performance.
%For more details on edabits versus Dalskov et al. the reader can check Table 10 in \cite{C:EGKRS20}.

The protocol is described in Figure~\ref{fig:truncpr-rep-ss}. The high-level
idea is to convert the replicated sharing $\share{\vx}$ to a $2$-out-of-$2$
additive sharing $\share{\vx}^{\mathsf{adt}}$ and then execute the truncation
protocol between two parties (Figure~\ref{fig:truncpr-generic}). The
preprocessing $\vr, \vr_\mathsf{msb}, \vr_\mathsf{top}$ for the 2PC computation
is generated by $P_3$ which is later additively shared to $P_1$ and $P_2$
(Figure~\ref{fig:get-additive}). After the two-party truncation is done, the
output share $\share{\vy'}^{\mathsf{adt}}$ is then converted back to a
replicated sharing $\share{\vy}^{\mathsf{rep}}$ using $\mathsf{AdtToRep}$.
Correctness and security follow from~\cite{PoPETS:DalEscKel20}.

In our implementation of the additive to replicated share conversions
we consider a more general variant, i.e. when an additive shared tensor
$\share{\cdot}^\mathsf{adt}$ is converted to a replicated secret
$\share{\cdot}^\mathsf{rep}$
where the host placements forming
$\mathsf{adt}$ are not necessarily a subset of the host placements
that define $\mathsf{rep}$ (see Protocol~\ref{fig:general-two-to-three}).


\msubsubsection
  {$\mathsf{TruncPr}_{[P_1, P_2, P_3]} \left(\Z_{2^k}; \share{\vx}^{\mathsf{rep}}_{2^k}, m \right)$}
  \label{fig:truncpr-rep-ss}
  Three party truncation protocol.

\begin{enumerate}
  \item Let $\left( (\vx_1^1, \vx_2^1), (\vx_2^2, \vx_3^2), (\vx_3^3, \vx_1^3) \right) = \share{\vx}^{\mathsf{rep}}_{2^k}$.

  \item On $P_3$:
  \begin{enumerate}
    \item $\shape \asn \mathsf{Shape}(\vx^3_3)$.
    \item $\mathbf{r} \asn \mathsf{SampleUniform}(\Z_{2^k}; \shape)$.
    \item $\mathbf{r}_{\mathsf{msb}} \asn \mathsf{Shr}(k-1; \mathbf{r})$.
    \item $\mathbf{r}_{\mathsf{top}} \asn \mathsf{Shr}(m+1; \mathsf{Shl}(1; \mathbf{r}))$.
  \end{enumerate}

  \item $\share{\vr}^{\mathsf{adt}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr)$

  \item $\share{\vr_{\mathsf{msb}}}^{\mathsf{adt}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr_{\mathsf{msb}})$

  \item $\share{\vr_{\mathsf{top}}}^{\mathsf{adt}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr_{\mathsf{top}})$

  \item $\share{\vx'}^{\mathsf{adt}} \asn \mathsf{ReplicatedToAdditive}_{[P_1, P_2]}(\share{\vx}^{\mathsf{rep}})$.

  \item $\share{\vy'}^{\mathsf{adt}} \asn \mathsf{2PCTruncPr}_{[P_1, P_2]}(\share{\vx'}^{\mathsf{adt}}, m, \share{\vr}^{\mathsf{adt}}, \share{\vr_{\mathsf{msb}}}^{\mathsf{adt}}, \share{\vr_{\mathsf{top}}}^{\mathsf{adt}} )$.

  \item Return $\share{\vy}^{\mathsf{rep}} \asn \mathsf{AdtToRep}_{[P_1, P_2, P_3]}(\share{\vy'}^{\mathsf{adt}})$.

\end{enumerate}

%  \begin{enumerate}
%    \item Each $P_i$ for $i \in [1, 2]$ sets the output of $\mathsf{TruncPr}$
%    as $y'_i$ and $\hat{y}_i$ as the sharing received from $P_3$. Send $y'_i -
%    \hat{y}_i$ to $P_{3-i}$. The received values are denoted by $\tilde{y}_i$.
%    \item $P_1$ sets the output share as $(y_1, y'_1 - \hat{y}_1 + \tilde{y}_1)$
%    \item $P_2$ sets the output share as $(y'_2 - \hat{y}_2 + \widehat{y}_2, y_3)$.
%  \end{enumerate}

\msubsubsection
  {$\mathsf{2PCTruncPr}_{[P_1, P_2]} \left( \share{\vx}, m, \share{\vr},
  \share{\vr_{\mathsf{msb}}}, \share{\vr_{\mathsf{top}}} \right)$}
  \label{fig:truncpr-generic}

  Two-party probabilistic truncation protocol. Assume $0 \leq \vx < 2^{\log_2{(R - 1})}$ in the unsigned representation.

  Since we deal with signed numbers the bounds are $-2^{\log_2{(R - 2)}} \leq x <
  2^{\log_2{(R - 2)}}$ in order to have enough room to make $\vx$ positive (i.e.
  add $2^{\log_2{(R-2)}}$) but also keep its MSB equal to $0$.

  Denote $k = \log_2(R) - 1$, considered in some literature as the unsigned input bound (in bits).

  \begin{enumerate}
  \item $\share{\vc} \asn \share{\vx} + 2^{k-1} + \share{\vr}$. By adding $2^{k-1}$ we make sure we mask a positive number.
  \item $\vc \asn \Open_{[P_1, P_2]}(\share{\vc})$.
  \item $\vc_{\mathsf{top}} \asn (\vc / 2^m) \bmod 2^{k-m-1}$.

  \item $\vc_{\mathsf{msb}} \asn \vc / 2^{k}$.
  \item $\share{\vw} \asn \share{\vr_{\mathsf{msb}}} \oplus \vc_{\mathsf{msb}}$. Note here that $a \oplus b = a + b - 2a\cdot b$.
  \item $\share{\vy_+} \asn \vc_{\mathsf{top}} - \share{\vr_{\mathsf{top}}} + \share{\vw}  \cdot 2^{k-m}$.
  \item Return $\share{\vy} \asn \share{\vy_+} - 2^{k-m-1}$.
\end{enumerate}


\msubsubsection
{$\mathsf{AdditiveShare}_{[D, P_1, P_2]}(R; \vx)$}
\label{fig:get-additive}
  Additive sharing protocol. Let $D$ be the party holding $\vx$.

  \begin{enumerate}
    \item On $D$:
  \begin{enumerate}
    \item $\shape \asn \mathsf{Shape}(\vx)$.
    \item $\vx^1 \asn \mathsf{SampleUniform}(R; \shape)$.
    \item $\vx^2 \asn \vx - \vx^1$.
    %\item Send $\shape$ and $\seed$ to $P_1$.
    \item Send $\vx^1$ to $P_1$.
    \item Send $\vx^2$ to $P_2$.
  \end{enumerate}
  \item On $P_1$:
  \begin{enumerate}
      \item Receive $\vx^1_1$ from $D$.
      %\item $\vx^1 \asn \RingSample(R; \mathsf{Shape}(\vx), \seed)$.
  \end{enumerate}
  \item On $P_2$:
  \begin{enumerate}
      \item Receive $\vx^2_2$ from $D$.
  \end{enumerate}
  \item Return $\share{\vx}^{\mathsf{adt}} = (\vx^1_1, \vx^2_2)$.
\end{enumerate}


\msubsubsection
{$\mathsf{ReplicatedToAdditive}_{[P_1, P_2]}\left( \share{\vx}^{\mathsf{rep}} \right)$}
\label{fig:replicated-to-additive}

  Conversion from a replicated share to an additive share.
  \begin{enumerate}

  \item Let $\left( (\vx_1^1, \vx_2^1), (\vx_2^2, \vx_3^2), (\vx_3^3, \vx_1^3) \right) = \share{\vx}^{\mathsf{rep}}$.

  \item On $P_1$:
    \begin{enumerate}
    \item $\vx'_1 \asn \vx^1_1 + \vx^1_2$.
    \end{enumerate}

  \item On $P_2$:
    \begin{enumerate}
    \item $\vx'_2 \asn \vx^2_3$.
    \end{enumerate}

  \item Return $\share{\vx'}^{\mathsf{adt}} = (\vx'_1, \vx'_2)$.
\end{enumerate}


\input{replicated/protocols/2-out-of-2}





