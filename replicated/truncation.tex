\subsection{Truncation}
\label{subsec:truncation}

Given a replicated tensor $\share{\vx}$, the goal of the truncation protocol is to compute $\share{\vx \bmod 2^m}$ where $m$ is a public constant.
%The ways of doing this can roughly be classified into two lines of thought: the more efficient but with a rounding error (probabilistic truncation) while the other slightly less efficient but with no rounding errors (deterministic truncation).
%Current state of the art techniques use dabits/edabits as described by Escudero et al. in \cite{C:EGKRS20} together with various share conversions. In~\cite{C:EGKRS20} there are several techniques to achieve both probabilistic and deterministic truncation for field and ring case.
For our semi-honest three-parties model we implement the probabilistic truncation from~\cite{PoPETS:DalEscKel20} which avoids preprocessing.
%and have slightly better performance.
%For more details on edabits versus Dalskov et al. the reader can check Table 10 in \cite{C:EGKRS20}.

The protocol is described in Fig~\ref{fig:truncpr-rep-ss}. At a high-level the idea is to convert the replicated sharing to a $(2,2)$ additive sharing and then execute the truncation protocol between two parties (Figure~\ref{fig:truncpr-generic}). The preprocessing for the 2PC computation is generated by $P_3$ which is later additively shared to $P_1$ and $P_2$ (Figure~\ref{fig:get-additive}). After the two-party truncation is done, the output share is then converted back to a replicated sharing (Figure~\ref{fig:two-to-three}). Correctness and security follow from~\cite{PoPETS:DalEscKel20}.


\begin{Boxfig}{Three party truncation protocol.}{fig:truncpr-rep-ss}{$\mathsf{TruncPr}_{[P_1, P_2, P_3]} \left(\Z_{2^k}; \share{\vx}^{\mathsf{rep}}_{2^k}, m \right)$}
\begin{enumerate}
  \item Let $\left( (\vx_1^1, \vx_2^1), (\vx_2^2, \vx_3^2), (\vx_3^3, \vx_1^3) \right) = \share{\vx}^{\mathsf{rep}}_{2^k}$.

  \item On $P_3$:
  \begin{enumerate}
    \item $\shape \asn \mathsf{Shape}(\vx^3_3)$.
    \item $\prfkey \asn \mathsf{GenPrfKey}()$.
    \item $\seed_\ell \asn \mathsf{DeriveSeed}(\ell; \prfkey)$ for $\ell \in [k]$.
    \item $\mathbf{b}_\ell \asn \mathsf{SampleBits}(\Z_{2^k}; \shape, \seed_\ell)$ for $\ell \in [k]$.
    \item $\mathbf{r} \asn \sum_{\ell=0}^{k-1}2^\ell \cdot \vb_\ell$
    \item $\mathbf{r}_{\mathsf{msb}} \asn \vb_{k-1}$
    \item $\mathbf{r}_{\mathsf{top}} \asn \sum_{\ell=m}^{k-2} 2^{\ell-m} \cdot \vb_\ell$.
  \end{enumerate}

  \item $\share{\vr}^{\mathsf{adt}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr)$

  \item $\share{\vr_{\mathsf{msb}}}^{\mathsf{adt}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr_{\mathsf{msb}})$

  \item $\share{\vr_{\mathsf{top}}}^{\mathsf{adt}} \asn \mathsf{AdditiveShare}_{[D=P_3, P_1, P_2]}(\vr_{\mathsf{top}})$

  \item $\share{\vx'}^{\mathsf{adt}} \asn \mathsf{ReplicatedToAdditive}_{[P_1, P_2]}(\share{\vx}^{\mathsf{rep}})$.

  \item $\share{\vy'}^{\mathsf{adt}} \asn \mathsf{2PCTruncPr}_{[P_1, P_2]}(\share{\vx'}^{\mathsf{adt}}, m, \share{\vr}^{\mathsf{adt}}, \share{\vr_{\mathsf{msb}}}^{\mathsf{adt}}, \share{\vr_{\mathsf{top}}}^{\mathsf{adt}} )$.

  \item Return $\share{\vy}^{\mathsf{rep}} \asn \mathsf{AdtToReplicated}_{[P_1, P_2, P_3]}(\share{\vy'}^{\mathsf{adt}})$.

\end{enumerate}

%  \begin{enumerate}
%    \item Each $P_i$ for $i \in [1, 2]$ sets the output of $\mathsf{TruncPr}$
%    as $y'_i$ and $\hat{y}_i$ as the sharing received from $P_3$. Send $y'_i -
%    \hat{y}_i$ to $P_{3-i}$. The received values are denoted by $\tilde{y}_i$.
%    \item $P_1$ sets the output share as $(y_1, y'_1 - \hat{y}_1 + \tilde{y}_1)$
%    \item $P_2$ sets the output share as $(y'_2 - \hat{y}_2 + \widehat{y}_2, y_3)$.
%  \end{enumerate}
\end{Boxfig}

\begin{Boxfig}{Two-party truncation protocol.}{fig:truncpr-generic}
  {$\mathsf{2PCTruncPr}_{[P_1, P_2]} \left( \share{\vx}, m, \share{\vr}, \share{\vr_{\mathsf{msb}}}, \share{\vr_{\mathsf{top}}} \right)$}

  Assume $\vx \in \Z_{2^k}^{\shape}$ has $\mathsf{MSB}(\vx) = 0$.
  \begin{enumerate}

  \item $\share{\vc} \asn \share{\vx} + \share{\vr}$.

  \item $\vc \asn \Open_{[P_1, P_2]}(\share{\vc})$.

  \item $\vc_{\mathsf{top}} \asn (\vc / 2^m) \bmod 2^{k-m-1}$.

  \item $\vc_{\mathsf{msb}} \asn \vc / 2^{k-1}$.

  \item $\share{\vb} \asn \share{\vr_{\mathsf{msb}}} \oplus \vc_{\mathsf{msb}}$. Note here that $a \oplus b = a + b - 2a\cdot b$.

  \item Return $\share{\vy} \asn \vc_{\mathsf{top}} - \share{\vr_{\mathsf{top}}} + \share{\vb} \cdot 2^{k-m-1}$.
\end{enumerate}

\end{Boxfig}


\begin{Boxfig}{Additive sharing.}{fig:get-additive}
  {$\mathsf{AdditiveShare}_{[D, P_1, P_2]}(R; \vx)$}

  Let $D$ be the party holding $\vx$.

  \begin{enumerate}
    \item On $D$:
  \begin{enumerate}
    \item $\shape \asn \mathsf{Shape}(\vx)$.
    \item $k \asn \mathsf{GenPrfKey}()$.
    \item $\seed \asn \derives(0; k)$.
    \item $\vx^1 \asn \RingSample(R; \shape, \seed)$.
    \item $\vx^2 \asn \vx - \vx^1$.
    %\item Send $\shape$ and $\seed$ to $P_1$.
    \item Send $\vx^1$ to $P_1$.
    \item Send $\vx^2$ to $P_2$.
  \end{enumerate}
  \item On $P_1$:
  \begin{enumerate}
      \item Receive $\vx^1_1$ from $D$.
      %\item $\vx^1 \asn \RingSample(R; \mathsf{Shape}(\vx), \seed)$.
  \end{enumerate}
  \item On $P_2$:
  \begin{enumerate}
      \item Receive $\vx^2_2$ from $D$.
  \end{enumerate}
  \item Return $\share{\vx}^{\mathsf{adt}} = (\vx^1_1, \vx^2_2)$.
\end{enumerate}
\end{Boxfig}

\begin{Boxfig}{Conversion from replicated shares to additive shares.}{fig:replicated-to-additive}
  {$\mathsf{ReplicatedToAdditive}_{[P_1, P_2]}\left( \share{\vx}^{\mathsf{rep}} \right)$}

  \begin{enumerate}

  \item Let $\left( (\vx_1^1, \vx_2^1), (\vx_2^2, \vx_3^2), (\vx_3^3, \vx_1^3) \right) = \share{\vx}^{\mathsf{rep}}$.

  \item On $P_1$:
    \begin{enumerate}
    \item $\vx'_1 \asn \vx^1_1 + \vx^1_2$.
    \end{enumerate}

  \item On $P_2$:
    \begin{enumerate}
    \item $\vx'_2 \asn \vx^2_3$.
    \end{enumerate}

  \item Return $\share{\vx'}^{\mathsf{adt}} = (\vx'_1, \vx'_2)$.
\end{enumerate}
\end{Boxfig}


\input{replicated/protocols/2-out-of-2}





