\subsection{Truncation}
Given secret shared $\share{a}$ the goal is to compute $\share{a \bmod 2^m}$
where $m$ is a public constant. This is also denoted as
$\mathsf{trunc}(\share{a}, m)$. There are many ways to truncate a secret that
can be roughly classified into two lines of thought: a) probabilistic
truncation where there is a rounding error with probability $p$ and b) deterministic
truncation where the output is always exact.

Current state of the art techniques in truncating a secret use
dabits/edabits as described by Escudero et al. in \cite{C:EGKRS20} and
various share conversions. In \cite{C:EGKRS20} there are several techniques
to achieve both probabilistic and deterministic truncation for field and ring
case. To avoid edabit generation required for generating random bounded integers
by the truncation protocols in \cite{C:EGKRS20} we use the protocols from
\cite{PoPETS:DalEscKel20}. We describe their probabilistic protocols for replicated secret
sharing below in Fig~\ref{fig:truncpr-rep-ss}.
Note that although the protocol in Fig~\ref{fig:truncpr-rep-ss} looks
very efficient, the edabit variant from \cite{C:EGKRS20} requires
about $\approx 35$ times less communication. \commentD{Need to re-check this, I think it's not that bad}



\begin{Boxfig}{Truncation protocol for semi-honest
RSS.}{fig:truncpr-rep-ss}{Protocol $\Proto{\mathsf{TruncPrSp}}$}
On input
$\mathsf{TruncPrSp}(\share{\vx}, m)$ from all parties where $\vx$ is a sharing
of a tensor over $\Z_{2^k}^{\mathsf{s}}$: \\
$P_3$ does the following:
  \begin{enumerate}
    \item Sample key $k_3 \sample \mathsf{SampleKey}()$.
    \item For $i \in [k]$ call $\mathsf{seed}_{\mathbf{b}_i} \asn \mathsf{derive\_seed}(k_3, i)$
    \item For $i \in [k]$ sample locally random bits $\mathbf{b}_i \in \Z_{2^k}^{\mathsf{s}}$.
    This is done by calling
    generate $\mathbf{b}_i \sample \mathsf{Sample}(\seed_{\mathbf{b}_i}, \mathsf{s}, [0,1])$.
    \item Compute
    $\mathbf{r}_{\mathsf{bot}} = \sum_{i=0}^{k-1}2^i \cdot \vb(i)$,
    $\mathbf{r}_{\mathsf{msb}} \asn \vb(k-1)$ and
    $\mathbf{r}_{\mathsf{top}} = \sum_{i=m}^{k-2} \vb(i) \cdot 2^{i-m}$. Send
    the corresponding shares to $P_1$ and $P_2$.
    \item For each of $\vr_{\mathsf{bot}}, \vr_{\mathsf{msb}} \vr_{\mathsf{top}}$
    generate 2-out-of-2 additive shares by calling $\Proto{\mathsf{GetAdditiveShare}}(\cdot)$
    on each entry and get $
    \vr\ui_{\mathsf{bot}}, \vr\ui_{\mathsf{msb}}, \vr\ui_{\mathsf{top}}$ for $i \in [0,1]$. Send the corresponding $\vr\ui$ to party $P_i$.
 \end{enumerate}
$P_1$ together with $P_2$ do the following:

\begin{enumerate}
   \item Convert $\share{x}$ into a $2$-out-of-$2$ sharing.
   \begin{enumerate}
      \item On $P_1$ set $\vx'_1 \asn \vx_1 + \vx_2$.
      \item On $P_2$ set $\vx'_2 \asn \vx_2$.
   \end{enumerate}

   \item $P_1$ and $P_2$ then execute the protocol $\Proto{\mathsf{TruncPR}}(\share{\vx'}, m)$
   using the $2$-out-of-$2$ sharing of $\vx$. Store the output as $\vy$.
\end{enumerate}

 Now parties convert the $2$-out-of-$2$ sharing $\vy$ to a $2$-out-of-$3$
 sharing. All parties output $\Proto{(2,2)\rightarrow(2,3)}(\vy)$.

%  \begin{enumerate}
%    \item Each $P_i$ for $i \in [1, 2]$ sets the output of $\mathsf{TruncPr}$
%    as $y'_i$ and $\hat{y}_i$ as the sharing received from $P_3$. Send $y'_i -
%    \hat{y}_i$ to $P_{3-i}$. The received values are denoted by $\tilde{y}_i$.
%    \item $P_1$ sets the output share as $(y_1, y'_1 - \hat{y}_1 + \tilde{y}_1)$
%    \item $P_2$ sets the output share as $(y'_2 - \hat{y}_2 + \widehat{y}_2, y_3)$.
%  \end{enumerate}
\end{Boxfig}

\begin{Boxfig}{Generic truncation protocol.}{fig:truncpr-generic}
  {Protocol $\Proto{\mathsf{TruncPr}}(\share{\vx}, m)$}
  Note this is a two party protocol, meaning only $P_1$ and $P_2$ are involved.
  Assume $\vx \in \Z_{2^k}^{\shape}$ has $\mathsf{MSB}(\vx) = 0$. If $\vx$ is negative then
  we make it positive by adding $2^{k-1}$ to it and assume that $\mathsf{abs}(\vx) < 2^{k-1}$.
  \\
  On $P_1$ and $P_2$:
  \begin{enumerate}
    \item Compute $\vc = \Open(\share{\vx} + \share{\vr_{\mathsf{bot}}})$.
    \item $\vc' \asn (\vc/2^m) \bmod 2^{k-m-1}$. This can be done using one $\mathsf{ring\_shl}$
    followed by one $\mathsf{ring\_shr}$ operation.
    \item Compute $\share{\vb} \asn \share{\vr_{\mathsf{msb}}} \oplus (\vc / 2^{k-1})$. Note here that $\oplus$
    in arithmetic circuits boils down to $a + b - 2a\cdot b$. Here one of the operands is public so
    the result can be computed using only local operations.
    \item Output $\vc' - \share{\vr_{\mathsf{top}}} + \share{\vb} \cdot 2^{k-m-1}$.
 \end{enumerate}

\end{Boxfig}


\begin{Boxfig}{Local conversion to $(2,2)$ additive shares}{fig:get-additive}
  {Protocol $\Proto{\mathsf{GetAdditive}}(\share{\vx}, P_3)$}
  On $P_3$:
  \begin{enumerate}
    \item $k \asn \mathsf{SampleKey}()$.
    \item $\seed \asn \derives(k, 0)$.
    \item Set $\vx^0 = \mathsf{Sample}(\vx.\mathsf{s}, \seed)$ and $\vx^1 = \vx - \vx^0$.
    \item Return $(\vx^0, \vx^1)$.
  \end{enumerate}

\end{Boxfig}

\begin{Boxfig}{Opening protocol}{fig:open2-2}
  {Protocol $\Proto{\Open}^{(2,2)}(\share{\vx})$}
  On $P_1$:
  \begin{enumerate}
    \item Send $\vx_1$ to $P_2$.
  \end{enumerate}
   On $P_2$:
  \begin{enumerate}
    \item Send $\vx_2$ to $P_1$.
  \end{enumerate}
  On $P_1$
  \begin{enumerate}
    \item Receive $\vx_2$ from $P_2$. Output
    $\vx \asn \vx_1 + \vx_2$.
  \end{enumerate}
  On $P_2$
  \begin{enumerate}
    \item Receive $\vx_1$ from $P_1$. Output $\vx \asn \vx_1 + \vx_2$.
  \end{enumerate}
\end{Boxfig}


% \begin{Boxfig}{Opening protocol}{fig:open2-3}
%   {Protocol $\Proto{\mathsf{OpenTo}}^{(2,3)}(\share{\vx})$}
%   On $P_i$:
%   \begin{enumerate}
%     \item Send $\vx_1$ to $P_2$.
%   \end{enumerate}
%    On $P_2$:
%   \begin{enumerate}
%     \item Send $\vx_2$ to $P_1$.
%   \end{enumerate}
%   On $P_1$
%   \begin{enumerate}
%     \item Receive $\vx_2$ from $P_2$. Output
%     $\vx \asn \vx_1 + \vx_2$.
%   \end{enumerate}
%   On $P_2$
%   \begin{enumerate}
%     \item Receive $\vx_1$ from $P_1$. Output $\vx \asn \vx_1 + \vx_2$.
%   \end{enumerate}
% \end{Boxfig}





