\subsection{Comparison}

%In order to compute the MAPE (mean absolute percentage error) metric which boils down to compute the absolute value of a secret $\share{|\vx|}$. Since our primitives work with ring arithmetic one of its most efficient evaluation of the absolute value is $\share{|\vx|} = \share{\vx} \cdot \share{\vx > 0}$.

The problem of computing secure comparisons translates directly into computing a sharing of the most significant bit $\share{\mathsf{msb}(\vx)}$.
In the 3PC semi-honest model there are few approaches to this:
\begin{enumerate}
   \item ABY3 \cite{CCS:MohRin18} The main idea is for
   each party to locally bit-decompose their shares over $\Z_{2^k}$ and then
   reconstruct the secret modulo $\Z_{2^k}$ using shares from $\Z^k_2$ and a
   binary adder. Once a boolean sharing of the MSB is computed using the binary adder
   this is converted to a ring sharing in $\Z_{2^k}$.
   In ABY3 this was done using a three-party OT protocol. In MP-SPDZ \cite{CCS:Keller20}
   the boolean to ring sharing conversion was achieved using a daBit.
   \item SecureNN \cite{PoPETS:WagGupCha19}
   similar to ABY3 with the downside that it uses arithmetic modulo
   some small fields but avoids ring-to-boolean conversion.
  \item Comparisons using edaBits \cite{C:EGKRS20}. The 3PC case has roughly the same cost as ABY3.
\end{enumerate}

We use the MSB extraction protocol from ABY3 with a Kogge-Stone binary adder and minor optimizations for tensor operations. We avoid the special three-party OT that ABY3 had along with edaBits preprocessing by introducing our custom protocol \textsf{B2A} for binary to ring share conversion in Figure~\ref{fig:b2a-protocol}.
The MSB protocol can be found in Figure~\ref{fig:msb-protocol} where $\overline{\cdot}$ is used to denote a vector with $k$ elements indexed using $(i)$ for $i \in [k]$.


\input{protocols/msb}

\subsubsection{Improved ABY3 boolean to ring sharing protocol}
When the inputs are tensors we can perform the share conversion $\share{\cdot}_2
\mapsto \share{\cdot}_{2^k}$ ($\mathsf{B2A}$ function)
more efficient by making use of the fact that all parties
follow the protocol specifications. The starting point is using a similar idea
from daBit/edaBit \cite{INDOCRYPT:RotWoo19,C:EGKRS20}
line of work with the twist that $P_3$ generates the preprocessing
material. We fully describe this share conversion protocol in Figure~\ref{fig:b2a-protocol}.

Acting as a trusted third party, $P_3$ generates a random daBit $(\share{\vb}_2,
\share{\vb}_{2^k})$ locally and shares it to $P_1$ and $P_2$. Then $P_1$ and
$P_2$ run a two-party protocol to convert $\share{\vx}_2$ to $\share{\vx}_{2^k}$
by computing $\vc \asn \vx_2 \oplus \vb_2$ and then locally XOR-ing in the
arithmetic domain $\vx_{2^k} = \vc + \vb_{2^k} - 2 \cdot \vc \cdot \vb_{2^k}$.
Finally they convert back to a replicated sharing using
$\mathsf{AdtToRep}$ from Figure~\ref{fig:two-to-three}. Note that in our
implementation of the additive to replicated share conversions we consider a
more general variant where $\share{\vx}^\mathsf{adt}$ is converted to
$\share{\vx}^\mathsf{rep}$ where the host placements on the additive placement
$\mathsf{adt}$ are not necessarily a subset of host placements composing $\mathsf{rep}$.

\input{protocols/b2a}
\input{protocols/dabit}
% \input{protocols/2-out-of-2.tex}
\input{protocols/abs}