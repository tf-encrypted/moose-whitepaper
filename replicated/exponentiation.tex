\subsection{Exponentiation (Not yet supported)}
\label{subsec:exp}

% def exp2_fx(a, zero_output=False):
% def exp_from_parts(whole_exp, frac):
%     class my_fix(type(a)):
%         pass
%     # improve precision
%     my_fix.set_precision(a.k - 2, a.k)
%     n_shift = a.k - 2 - a.f
%     x = my_fix._new(frac.v << n_shift)
%     # evaluates fractional part of a in p_1045
%     e = p_eval(p_1045, x)
%     g = a._new(whole_exp.TruncMul(e.v, 2 * a.k, n_shift,
%                                        nearest=a.round_nearest), a.k, a.f)

%     return g

% x = a.v.split_to_two_summands(a.k)
% bits = types._bitint.carry_lookahead_adder(x[0], x[1],
%                                                     fewer_inv=False)
% # converting MSB first reduces the number of rounds
% s = sint.conv(bits[-1])
% lower_overflow = sint.conv(x[0][a.f]) + \
%                     sint.conv(x[0][a.f] ^ x[1][a.f] ^ bits[a.f])
% lower = a.v.raw_mod2m(a.f) - (lower_overflow << a.f)

% c = types.sfix._new(lower, k=a.k, f=a.f)
% assert(len(higher_bits) == n_bits - a.f)
% pow2_bits = [sint.conv(x) for x in higher_bits]
% d = floatingpoint.Pow2_from_bits(pow2_bits)
% g = exp_from_parts(d, c)
% small_result = types.sfix._new(g.v.round(a.f + 2 ** n_int_bits,
%                                     2 ** n_int_bits, signed=False,
%                                     nearest=types.sfix.round_nearest),
%                                 k=a.k, f=a.f)
% if zero_output:
%     small_result = t.if_else(small_result, 0)
% return s.if_else(small_result, g)